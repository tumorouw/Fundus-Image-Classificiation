# import library yang diperlukan

import tensorflow as tf
from keras import layers
from keras.optimizers import Adam
from keras.callbacks import EarlyStopping

# tentukan dataset dan set size citra

data_dir = "/content/drive/MyDrive/Dataset"
batch_size = 32
img_height = 224
img_width = 224

datagen = tf.keras.preprocessing.image.ImageDataGenerator(
      rescale=1./255,
      rotation_range=40,
      width_shift_range=0.2,
      height_shift_range=0.2,
      shear_range=0.2,
      zoom_range=0.2,
      horizontal_flip=True,
      fill_mode='nearest',
      validation_split=0.2
)

#load train dataset with datagen from directory

train_ds = datagen.flow_from_directory(
    data_dir,
    target_size=(img_height, img_width),
    batch_size=batch_size,
    class_mode='categorical',
    subset='training',
    seed=123
)

# Get the class names and number of classes
class_names = train_ds.class_indices
num_classes = len(class_names)
print(class_names)

#load validation dataset with datagen from directory

val_ds = datagen.flow_from_directory(
    data_dir,
    target_size=(img_height, img_width),
    batch_size=batch_size,
    class_mode='categorical',
    subset='validation',
    seed=123
)

# build cnn model
model = tf.keras.Sequential([
    layers.Conv2D(32, 3, padding='same', activation='relu', input_shape=(img_height, img_width, 3)),
    layers.MaxPooling2D(3,3),
    layers.Dropout(0.5),
    layers.Conv2D(64, 3, padding='same', activation='relu'),
    layers.MaxPooling2D(3,3),
    layers.Dropout(0.5),
    layers.Conv2D(128, 3, padding='same', activation='relu'),
    layers.MaxPooling2D(3,3),
    layers.Dropout(0.5),
    layers.Flatten(),
    layers.Dense(128, activation='relu'),
    layers.Dense(num_classes, activation='softmax')
])

#compile model

model.compile(optimizer=Adam(learning_rate=0.001),
              loss='categorical_crossentropy',
              metrics=['accuracy'])

#model summary

model.summary()

import matplotlib.pyplot as plt

# Define early stopping
early_stopping = EarlyStopping(monitor='val_loss', patience=3)

# Train the model with early stopping
epochs = 10
history = model.fit(train_ds, epochs=epochs, validation_data=val_ds, callbacks=[early_stopping])

# Visualize the training and validation accuracy
plt.plot(history.history['accuracy'], label='Training Accuracy')
plt.plot(history.history['val_accuracy'], label='Validation Accuracy')
plt.xlabel('Epoch')
plt.ylabel('Accuracy')
plt.legend()
plt.show()

# Visualize the training and validation loss
plt.plot(history.history['loss'], label='Training Loss')
plt.plot(history.history['val_loss'], label='Validation Loss')
plt.xlabel('Epoch')
plt.ylabel('Loss')
plt.legend()
plt.show()

# Save the model
model.save("classify.h5")

from keras.preprocessing.image import ImageDataGenerator
import numpy as np

# Create an instance of ImageDataGenerator with desired preprocessing/augmentation options
test_data_gen = ImageDataGenerator(rescale=1./255)

# Generate batches of test data
test_data = test_data_gen.flow_from_directory(
    '/content/drive/MyDrive/Dataset',
    target_size=(img_height, img_width),
    batch_size=batch_size,
    class_mode='binary',
    shuffle=False
)

# Load the saved model
model = tf.keras.models.load_model('classify.h5')

# Make predictions on the test data
predictions = model.predict(test_data)

## Convert the predicted labels to integers
predicted_labels = np.argmax(predictions, axis=1)

# Get the true labels as integers
true_labels = test_data.classes

# Calculate accuracy
accuracy = np.mean(predicted_labels == true_labels)
print('Accuracy:', accuracy)

# Load the saved model
model = tf.keras.models.load_model('classify.h5')

##### prediction on new images

from tensorflow.keras.preprocessing import image
import numpy as np

# Load the image
img_path = "/content/Images/OIP.jpg"
img = image.load_img(img_path, target_size=(img_height, img_width))
img_array = image.img_to_array(img)
img_array = np.expand_dims(img_array, axis=0)
img_array = img_array / 255.0  # Normalize pixel value
plt.imshow(img)

# Make predictions on the new image
predictions = model.predict(img_array)
predicted_label = np.argmax(predictions)

# Map the predicted label to the corresponding class
class_names = ['dogs', 'wolves']
predicted_class = class_names[predicted_label]

print('Predicted class:', predicted_class)
